<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Nginx 指令的执行顺序 | 天青色等烟雨</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.2"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-87247047-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Nginx 指令的执行顺序</h1><a id="logo" href="/.">天青色等烟雨</a><p class="description">文不在多、有换则新、人不在挤、有来就行</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Nginx 指令的执行顺序</h1><div class="post-meta">Apr 28, 2018<span> | </span><span class="category"><a href="/categories/nginx/">nginx</a></span></div><div class="post-content"><p>nginx的处理过程总共分为11个阶段，分别是<code>post-read</code>、<code>server-rewrite</code>、<code>find-config</code>、<code>rewrite</code>、<code>post-rewrite</code>、<code>preaccess</code>、<code>access</code>、<code>post-access</code>、<code>try-files</code>、<code>content</code>, <code>log</code>。</p>
<a id="more"></a>
<p><ul class="markdownIt-TOC">
<li><a href="#post-read">post-read</a></li>
<li><a href="#server-rewrite">server-rewrite</a></li>
<li><a href="#find-config">find-config</a></li>
<li><a href="#rewrite">rewrite</a></li>
<li><a href="#post-rewrite">post-rewrite</a></li>
<li><a href="#preaccess-%E9%98%B6%E6%AE%B5">preaccess 阶段</a></li>
<li><a href="#access-%E9%98%B6%E6%AE%B5">access 阶段</a></li>
<li><a href="#post-access-%E9%98%B6%E6%AE%B5">post-access 阶段</a></li>
<li><a href="#try-files-%E9%98%B6%E6%AE%B5">try-files 阶段</a></li>
<li><a href="#content-%E9%98%B6%E6%AE%B5">content 阶段</a></li>
<li><a href="#log-%E9%98%B6%E6%AE%B5">log 阶段</a></li>
</ul>
</p>
<h2><span id="post-read"> post-read</span></h2>
<p>在nginx读取解析请求头后执行: <code>set_real_ip_from</code> ,<code>read_ip_head</code></p>
<p>该阶段是在Nginx读取并解析完请求头（request headers）之后就立即开始执行的，标准模块的ngx_realip就是在post-read阶段注册了处理程序。它的功能是迫使 Nginx 认为当前请求的来源地址是指定的某一个请求头的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line"></span><br><span class="line">        set_real_ip_from 127.0.0.1;</span><br><span class="line">        real_ip_header   X-My-IP;</span><br><span class="line"></span><br><span class="line">        location /test &#123;</span><br><span class="line">            set $addr $remote_addr;</span><br><span class="line">            echo &quot;from: $addr&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的配置是让 Nginx 把那些来自 127.0.0.1 的所有请求的来源地址，都改写为请求头 X-My-IP 所指定的值。同时该例使用了标准内建变量 $remote_addr 来输出当前请求的来源地址，以确认是否被成功改写。</p>
<h2><span id="server-rewrite"> server-rewrite</span></h2>
<p>当 ngx_rewrite 模块的配置指令直接书写在 server 配置块中时，基本上都是运行在 server-rewrite 阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line"></span><br><span class="line">        location /test &#123;</span><br><span class="line">            set $b &quot;$a, world&quot;;</span><br><span class="line">            echo $b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set $a hello;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>配置语句 set $a hello 直接写在了 server 配置块中，因此它就运行在 server-rewrite 阶段</p>
<h2><span id="find-config"> find-config</span></h2>
<p>紧接在 server-rewrite 阶段后边的是 find-config 阶段。这个阶段并不支持 Nginx 模块注册处理程序，而是由 Nginx 核心来完成当前请求与 location 配置块之间的配对工作。换句话说，在此阶段之前，请求并没有与任何 location 配置块相关联。因此，对于运行在 find-config 阶段之前的 post-read 和 server-rewrite 阶段来说，只有 server 配置块以及更外层作用域中的配置指令才会起作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /hello &#123;</span><br><span class="line">    echo &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果启用了 Nginx 的“调试日志”，那么当请求 /hello 接口时，便可以在 error.log 文件中过滤出下面这一行信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep &apos;using config&apos; logs/error.log</span><br><span class="line">[debug] 84579#0: *1 using configuration &quot;/hello&quot;</span><br></pre></td></tr></table></figure>
<h2><span id="rewrite"> rewrite</span></h2>
<p>运行在 find-config 阶段之后的便是我们的老朋友 rewrite 阶段。由于 Nginx 已经在 find-config 阶段完成了当前请求与 location 的配对，所以从 rewrite 阶段开始，location 配置块中的指令便可以产生作用。前面已经介绍过，当 ngx_rewrite 模块的指令用于 location 块中时，便是运行在这个 rewrite 阶段。</p>
<h2><span id="post-rewrite"> post-rewrite</span></h2>
<p>rewrite 阶段再往后便是所谓的 post-rewrite 阶段。这个阶段也像 find-config 阶段那样不接受 Nginx 模块注册处理程序，而是由 Nginx 核心完成 rewrite 阶段所要求的“内部跳转”操作（如果 rewrite 阶段有此要求的话）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line"></span><br><span class="line">        location /foo &#123;</span><br><span class="line">            set $a hello;</span><br><span class="line">            rewrite ^ /bar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /bar &#123;</span><br><span class="line">            echo &quot;a = [$a]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里在 location /foo 中通过 rewrite 指令把当前请求的 URI 无条件地改写为 /bar，同时发起一个“内部跳转”，最终跳进了 location /bar 中。这里比较有趣的地方是内部跳转的工作原理。内部跳转 本质上其实就是把当前的请求处理阶段强行倒退到 find-config 阶段，以便重新进行请求 URI 与 location 配置块的配对。比如上例中，运行在 rewrite 阶段的 rewrite 指令就让当前请求的处理阶段倒退回了 find-config 阶段。由于此时当前请求的 URI 已经被 rewrite 指令修改为了 /bar，所以这一次换成了 location /bar 与当前请求相关联，然后再接着从 rewrite 阶段往下执行。</p>
<p>不过这里更有趣的地方是，倒退回 find-config 阶段的动作并不是发生在 rewrite 阶段，而是发生在后面的 post-rewrite 阶段。上例中的 rewrite 指令只是简单地指示 Nginx 有必要在 post-rewrite 阶段发起“内部跳转”。这个设计对于 Nginx 初学者来说，或许显得有些古怪：“为什么不直接在 rewrite 指令执行时立即进行跳转呢？”答案其实很简单，那就是为了在最初匹配的 location 块中支持多次反复地改写 URI，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">        rewrite ^ /bar;</span><br><span class="line">        rewrite ^ /baz;</span><br><span class="line"></span><br><span class="line">        echo foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /bar &#123;</span><br><span class="line">        echo bar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /baz &#123;</span><br><span class="line">        echo baz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里在 location /foo 中连续把当前请求的 URI 改写了两遍：第一遍先无条件地改写为 /bar，第二遍再无条件地改写为 /baz. 而这两条 rewrite 语句只会最终导致 post-rewrite 阶段发生一次“内部跳转”操作，从而不至于在第一次改写 URI 时就直接跳离了当前的 location 而导致后面的 rewrite 语句没有机会执行。请求 /foo 接口的结果证实了这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/foo</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>从输出结果可以看到，上例确实成功地从 /foo 一步跳到了 /baz 中。如果启用 Nginx “调试日志”的话，还可以从 find-config 阶段生成的 location 块的匹配信息中进一步证实这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep &apos;using config&apos; logs/error.log</span><br><span class="line">[debug] 89449#0: *1 using configuration &quot;/foo&quot;</span><br><span class="line">[debug] 89449#0: *1 using configuration &quot;/baz&quot;</span><br></pre></td></tr></table></figure>
<p>我们看到，对于该次请求，Nginx 一共只匹配过 /foo 和 /baz 这两个 location，从而只发生过一次“内部跳转”。</p>
<p>当然，如果在 server 配置块中直接使用 rewrite 配置指令对请求 URI 进行改写，则不会涉及“内部跳转”，因为此时 URI 改写发生在 server-rewrite 阶段，早于执行 location 配对的 find-config 阶段。比如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line"></span><br><span class="line">        rewrite ^/foo /bar;</span><br><span class="line"></span><br><span class="line">        location /foo &#123;</span><br><span class="line">            echo foo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /bar &#123;</span><br><span class="line">            echo bar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们在 server-rewrite 阶段就把那些以 /foo 起始的 URI 改写为 /bar，而此时请求并没有和任何 location 相关联，所以 Nginx 正常往下运行 find-config 阶段，完成最终的 location 匹配。如果我们请求上例中的 /foo 接口，那么 location /foo 根本就没有机会匹配，因为在第一次（也是唯一的一次）运行 find-config 阶段时，当前请求的 URI 已经被改写为 /bar，从而只会匹配 location /bar.</p>
<h2><span id="preaccess-阶段"> preaccess 阶段</span></h2>
<p>标准模块 ngx_limit_req 和 ngx_limit_zone 就运行在此阶段，前者可以控制请求的访问频度，而后者可以限制访问的并发度。</p>
<h2><span id="access-阶段"> access 阶段</span></h2>
<p>标准模块 ngx_access、第三方模块 ngx_auth_request 以及第三方模块 ngx_lua 的 access_by_lua 指令就运行在这个阶段。</p>
<h2><span id="post-access-阶段"> post-access 阶段</span></h2>
<p>post-access 阶段主要用于配合 access 阶段实现标准 ngx_http_core 模块提供的配置指令 satisfy 的功能。<br>
对于多个 Nginx 模块注册在 access 阶段的处理程序， satisfy 配置指令可以用于控制它们彼此之间的协作方式。比如模块 A 和 B 都在 access 阶段注册了与访问控制相关的处理程序，那就有两种协作方式，一是模块 A 和模块 B 都得通过验证才算通过，二是模块 A 和模块 B 只要其中任一个通过验证就算通过。第一种协作方式称为 all 方式（或者说“与关系”），第二种方式则被称为 any 方式（或者说“或关系”）。默认情况下，Nginx 使用的是 all 方式。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">        satisfy all;</span><br><span class="line"></span><br><span class="line">        deny all;</span><br><span class="line">        access_by_lua &apos;ngx.exit(ngx.OK)&apos;;</span><br><span class="line"></span><br><span class="line">        echo something important;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们在 /test 接口中同时配置了 ngx_access 模块和 ngx_lua 模块，这样 access 阶段就由这两个模块一起来做检验工作。其中，语句 deny all 会让 ngx_access 模块的处理程序总是拒绝当前请求，而语句 access_by_lua ‘ngx.exit(ngx.OK)’ 则总是允许访问。当我们通过 satisfy 指令配置了 all 方式时，就需要 access 阶段的所有模块都通过验证，但不幸的是，这里 ngx_access 模块总是会拒绝访问，所以整个请求就会被拒.</p>
<h2><span id="try-files-阶段"> try-files 阶段</span></h2>
<p>这个阶段专门用于实现标准配置指令 try_files 的功能，并不支持 Nginx 模块注册处理程序。<br>
try_files 指令接受两个以上任意数量的参数，每个参数都指定了一个 URI. 这里假设配置了 N 个参数，则 Nginx 会在 try-files 阶段，依次把前 N-1 个参数映射为文件系统上的对象（文件或者目录），然后检查这些对象是否存在。一旦 Nginx 发现某个文件系统对象存在，就会在 try-files 阶段把当前请求的 URI 改写为该对象所对应的参数 URI（但不会包含末尾的斜杠字符，也不会发生 “内部跳转”）。如果前 N-1 个参数所对应的文件系统对象都不存在，try-files 阶段就会立即发起“内部跳转”到最后一个参数（即第 N 个参数）所指定的 URI.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root /var/www/;</span><br><span class="line"></span><br><span class="line">    location /test &#123;</span><br><span class="line">        try_files /foo /bar/ /baz;</span><br><span class="line">        echo &quot;uri: $uri&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /foo &#123;</span><br><span class="line">        echo foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /bar/ &#123;</span><br><span class="line">        echo bar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /baz &#123;</span><br><span class="line">        echo baz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里通过 root 指令把“文档根目录”配置为 /var/www/，如果你系统中的 /var/www/ 路径下存放有重要数据，则可以把它替换为其他任意路径，但此路径对运行 Nginx worker 进程的系统帐号至少有可读权限。我们在 location /test 中使用了 try_files 配置指令，并提供了三个参数，/foo、/bar/ 和 /baz. 根据前面对 try_files 指令的介绍，我们可以知道，它会在 try-files 阶段依次检查前两个参数 /foo 和 /bar/ 所对应的文件系统对象是否存在。</p>
<p>不妨先来做一组实验。假设现在 /var/www/ 路径下是空的，则第一个参数 /foo 映射成的文件 /var/www/foo 是不存在的；同样，对于第二个参数 /bar/ 所映射成的目录 /var/www/bar/ 也是不存在的。于是此时 Nginx 会在 try-files 阶段发起到最后一个参数所指定的 URI（即 /baz）的“内部跳转”。实际的请求结果证实了这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/test</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>显然，该请求最终和 location /baz 绑定在一起，执行了输出 baz 字符串的工作。上例中定义的 location /foo 和 location /bar/ 完全不会参与这里的运行过程，因为对于 try_files 的前 N-1 个参数，Nginx 只会检查文件系统，而不会去执行 URI 与 location 之间的匹配。</p>
<p>try-files 阶段发生的事情：Nginx 依次检查了文件 /var/www/foo 和目录 /var/www/bar，末了又处理了最后一个参数 /baz. 这里最后一条“调试信息”容易产生误解，会让人误以为 Nginx 也把最后一个参数 /baz 给映射成了文件系统对象进行检查，事实并非如此。当 try_files 指令处理到它的最后一个参数时，总是直接执行“内部跳转”，而不论其对应的文件系统对象是否存在。</p>
<h2><span id="content-阶段"> content 阶段</span></h2>
<p>content阶段主要是处理内容输出的阶段。这里要注意的是绝大多数 Nginx 模块在向 content 阶段注册配置指令时，本质上是在当前的 location 配置块中注册所谓的“内容处理程序”（content handler）。每一个 location 只能有一个“内容处理程序”，因此，当在 location 中同时使用多个模块的 content 阶段指令时，只有其中一个模块能成功注册“内容处理程序”。例如 echo 和 content_by_lua 如果同时注册，最终只会有一个生效，但具体是哪一个生效是不稳定的。</p>
<h2><span id="log-阶段"> log 阶段</span></h2>
<p>日志的记录阶段</p>
<p>参考链接：</p>
<ol>
<li><a href="https://www.jianshu.com/p/0cc0f4c9a005" target="_blank" rel="noopener">https://www.jianshu.com/p/0cc0f4c9a005</a></li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.2" async></script><a class="article-share-link" data-url="yunke.science/2018/04/28/nginx-process/" data-id="cjm8uskwo003h2ovhaccmb5ga" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABuElEQVR42u3aOXLEMAwEwP3/p+XUgSVhAJGWXc1oay81ExSuz6d8jm/n+jtnr6/fefjg4uKOucflqTzgDNq70pkBFxd3P3ddYJpcEhcX969wK7+t/AoXF/c/cesp0fW/4eLivp9bf3ya0FxfdWGthouLO+DWu5TrXi/p7+Li4ra4R3gmaVCaKv3wD7i4uFu49YBSTzvSEige7uLi4i7mnj2+F4Z6ixrBp7i4uFu4aaiatCombdZSLwcXF/dR7qTsebbIiaMvLi7uYm5v5aKOqKdTNwZcXNyN3AoiTWUm5U1QseHi4j7KrS9I1UNbJeTVP71pmOLi4i7g1gelvXd6K1zBkBUXF3c7N13V6g1f45IJFxd3CzdtjkyWsdKRzANtU1xc3HG3oTLeqBcqk8s0h6y4uLhbuHVis5hJN69wcXF/iZsWPL0mSPPg4uIu5k5CWG+4MkmYcHFx93DnwW6ybFG/dozGxcUdc3vBK22wpgHrZoiCi4u7hTsPNOmiRnN8i4uL+0rupIU6b6/g4uK+k1uvpXqXuRHi4uJu5KYj1Qp6SdMEFxd3CzcNJWkBM0mMRv1dXFzcDvcLH8DiMWZa4gYAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/nginx/">nginx</a></div><div class="post-nav"><a class="pre" href="/2018/04/30/redis-aof/">Redis AOF文件 重写操作导致的磁盘和内存不足的问题</a><a class="next" href="/2018/04/26/nginx-rewrite/">创建NGINX重写规则</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.2"><script src="/js/gitment.browser.js?v=0.0.2"></script><script>var gitment = new Gitment({
  owner: 'young-0',
  repo: 'young-0.github.io',
  oauth: {
    client_id: '967eeda5599f16063a0a',
    client_secret: '0c5aaeec2649210043608d7a09c7d19f0795f3f9',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="yunke.science"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kubernetes/">Kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/elk/">elk</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/fiction/">fiction</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubernetes/">kubernetes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/monitor/">monitor</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/美文/">美文</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/monitor/" style="font-size: 15px;">monitor</a> <a href="/tags/Kubernetes/" style="font-size: 15px;">Kubernetes</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/openresty/" style="font-size: 15px;">openresty</a> <a href="/tags/LuaRocks/" style="font-size: 15px;">LuaRocks</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/traefik/" style="font-size: 15px;">traefik</a> <a href="/tags/fiction/" style="font-size: 15px;">fiction</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/elk/" style="font-size: 15px;">elk</a> <a href="/tags/crond/" style="font-size: 15px;">crond</a> <a href="/tags/alpine/" style="font-size: 15px;">alpine</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/美文/" style="font-size: 15px;">美文</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/kcptun/" style="font-size: 15px;">kcptun</a> <a href="/tags/zabbix/" style="font-size: 15px;">zabbix</a> <a href="/tags/情商/" style="font-size: 15px;">情商</a> <a href="/tags/智商/" style="font-size: 15px;">智商</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/19/cka-faq/">CKA常见问题解答</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/redis-security/">redis 安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/http2-server-push/">使用NGINX 1.13.9引入HTTP2服务器推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/10/kubectl-overview/">kubectl概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/kuberouter-guide/">Kube-router 用户指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/18/k8sNetworkPolicy/">kubernetes 网络策略简单配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/17/microsrv-advant/">微服务架构的优势</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/16/architec-distri/">分布式服务架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/16/architec-growth/">快速成长期架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/16/architec-initial/">初创期架构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="advanced-bash-scripting-guide-in-chinese/" title="高级Bash脚本编程指南" target="_blank">高级Bash脚本编程指南</a><ul></ul><a href="http://www.colasoft.com.cn/training/document.php" title="网络分析技术学习资料" target="_blank">网络分析技术学习资料</a><ul></ul><a href="https://k8smeetup.github.io/docs/home/" title="Kubernetes 文档" target="_blank">Kubernetes 文档</a><ul></ul><a href="https://www.bilibili.com/video/av21179285" title="TCPIP协议详解" target="_blank">TCPIP协议详解</a><ul></ul><a href="https://www.bilibili.com/video/av21540971" title="python数据结构与算法系列课程" target="_blank">python数据结构与算法系列课程</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">天青色等烟雨.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.2" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.2" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.2"></script></div></body></html>